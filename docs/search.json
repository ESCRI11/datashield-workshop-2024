[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DataSHIELD Workshop",
    "section": "",
    "text": "Introduction\nThis website has been created to host the materials and exercises for the Advanced Users’ DataSHIELD Workshop, hosted at the Center for Mathematics of the University of Bonn Thursday 26th September 2024.\nOn it you will find reading materials, setup tutorials, the workshop indications and practical exercises.\n\n\nGetting started\nBefore the workshop we suggest the atendants to take a look at the “Environment setup” and “Get up to speed” sections. This way they will have their computers with the right software installed to follow the workshop.\nDue the nature of this workshop, the attendants are expected to have some notions of R package development, to cover the basics we included a section titled “R packages 101”, if you are not familiar with R package development please take a look before the workshop.\n\n\nSchedule\nTo be delivered.\n\n\nAcknowledgements\nThis work is funded by XXX and XXX. Materials developed by Juan R. González (ISGlobal) and Xavier Escribà Montagut (BigOmics Analytics SA).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "env_setup.html",
    "href": "env_setup.html",
    "title": "Environment setup",
    "section": "",
    "text": "R packages\nIn order to develop, test and push our new DataSHIELD packages, we will require the following R packages to be installed:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Environment setup</span>"
    ]
  },
  {
    "objectID": "env_setup.html#install-guide",
    "href": "env_setup.html#install-guide",
    "title": "Environment setup",
    "section": "Install guide",
    "text": "Install guide\nWhen using R, we are used to installing packages with the handy install.packages() function. However, by default it uses the CRAN repository, which does not contain all the required packages. For that reason we provide a quick code snippet to install all the required packages:\n\n# Install DSLite\ninstall.packages(\"DSLite\")\n\n# Install DSI\ninstall.packages(\"DSI\")\n\n# Install dsBase\ninstall.packages(\n    'dsBase',\n    repos=c(\n        getOption('repos'),\n        'http://cran.datashield.org'\n    ),\n    dependencies=TRUE\n)\n\n# Install dsBaseClient\ninstall.packages(\n    'dsBaseClient',\n    repos=c(\n        getOption('repos'),\n        'http://cran.datashield.org'\n    ),\n    dependencies=TRUE\n)\n\nWith that, your environment will be ready to take on the workshop. Nevertheless, please read the next sessions to familiarize with R package development if you are not already.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Environment setup</span>"
    ]
  },
  {
    "objectID": "up_2_speed.html",
    "href": "up_2_speed.html",
    "title": "Get up to speed",
    "section": "",
    "text": "Developing your first R package\nDuring the workshop it will be assumed that the attendats have already prior knowledge about building a regular R package. If that was not the case, we provide some useful links to prepare in advance, as with the environment setup, feel free to contact the authors before the workshop to solve any doubts.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Get up to speed</span>"
    ]
  },
  {
    "objectID": "up_2_speed.html#developing-your-first-r-package",
    "href": "up_2_speed.html#developing-your-first-r-package",
    "title": "Get up to speed",
    "section": "",
    "text": "R packages\nusethis package\nroxygen2\n\n\n\n\n\n\n\nTip\n\n\n\nIf you are not confident in your basic R package building skills, we suggest creating your first package before the workshop.\nA good exercise would be to use the usethis package to setup the basic R package structure, create a simple helloWorld() function and document it using roxygen2.\nHere, you can see how that would looke like once finished. REPO de resultats",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Get up to speed</span>"
    ]
  },
  {
    "objectID": "up_2_speed.html#footnotes",
    "href": "up_2_speed.html#footnotes",
    "title": "Get up to speed",
    "section": "",
    "text": "From Xavier Escribà↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Get up to speed</span>"
    ]
  },
  {
    "objectID": "1-datashield-packages-structure.html",
    "href": "1-datashield-packages-structure.html",
    "title": "1. DataSHIELD packages structure",
    "section": "",
    "text": "Naming conventions\nAs with many different software and architectures, there are a set of (somtimes un-) written rules that developers stick to. In this case, no official writting is available, so this document can serve as a starting point.\nFirst and foremost, use camelCase naming convention.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>1. DataSHIELD packages structure</span>"
    ]
  },
  {
    "objectID": "1-datashield-packages-structure.html#naming-conventions",
    "href": "1-datashield-packages-structure.html#naming-conventions",
    "title": "1. DataSHIELD packages structure",
    "section": "",
    "text": "Naming the client package\nThe naming for the client package will follow this rule\ndsXxxClient\nWhere Xxx is the actual name. E.g. a metabolomics exposome package could be named dsMetabolomicsClient.\n\n\nNaming of the server package\nThe server package will use the same Xxx and be named as\ndsXxx\nFollowing on the metabolomics example we would have dsMetabolomics.\n\n\nFunction naming on the client\nThe naming of functions on the client package will follow\nds.Xxx\nE.g. in metabolomics ds.ComputeMetaboScore.\n\n\nFunction naming on the server\nMost times a client function will call a specific one on the server, therefore we name them the same.\nXxxDS\nE.g. in metabolomics ComputeMetaboScoreDS.\nPlease note this is not a strict rule, it is just a good practice. If all developers stick to ~ similar ~ rules, the feel for the actual users will be smoother, which will improve engagement on the project.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>1. DataSHIELD packages structure</span>"
    ]
  },
  {
    "objectID": "1-datashield-packages-structure.html#dsi-communicating-from-client-to-server",
    "href": "1-datashield-packages-structure.html#dsi-communicating-from-client-to-server",
    "title": "1. DataSHIELD packages structure",
    "section": "DSI: Communicating from client to server",
    "text": "DSI: Communicating from client to server\nNow that we understand why two packages are required and how to name them, let’s see which tool we have to perform communications between them. The tool that we will use is called DSI, short for “DataSHIELD Interface”. This tool will allow us to send queries from the packages on the client to the server ones, as well as recieve the server response with the results that we want to use or show the the researcher.\n\n\n\n\n\n\nNote\n\n\n\nThe DSI package is also responsible for creating connections to the server (datashield.login), handling workspaces (datashield.workspaces) and many other stuff, this is not connected to package development.\n\n\n\nCommunication types\nWith DSI there are two different types of communications we can perform, one telling the server to assign the result of a function to a variable, the other telling the server to return the result of a function. It is important to notice that not any function can be used; we, as package developers, will develop a set of functions on the server package and each of them will only be available to be used one way or another, therefore, this information will be specified on the server package (see DATASHIELD file).\nGiven that these functions communicate from the client package to the server package, they will only be used on the client package. It is important to note that to function they will require the information to which servers to talk to, more on this in a second (The datasources object).\n\nAssign functions\nAssign functions, as the name implies, will assign something to the R session that is running on the server. For example if we have loaded a data table, we can write a function that takes the first two columns and assigns it to a new variable.\n\n\n\n\n\nsequenceDiagram\n    Client-&gt;&gt;+Server: Run `helloWorld()` and assign the results to a variable named \"hello\"\n    Server--&gt;&gt;-Client: Done deal boss (but in silence)\n\n\n\n\n\n\nPlease note that after running an assign function, the client does not recieve anything, hence (but in silence) on the diagram.\nCode-wise this will look like this\n\nDSI::datashield.assign.expr(\n  conns = conns,\n  symbol = \"hello\",\n  expr = call(\"helloWorld()\")\n)\n\nWe are passing to the DSI::datashield.assign.expr function 1 the conns object (more on this here The datasources object), 2 the variable where the result will be assigned on the server and 3 the function whose result will be assigned to the new variable.\n\n\nAggregate functions\nAggregate functions will run a function on the server and the result will be sent to the client. Beware, a poorly written function on the server might be able to return raw data to the client, completely defeating the point of using DataSHIELD. The process in this case looks like this\n\n\n\n\n\nsequenceDiagram\n    Client-&gt;&gt;+Server: Run `helloWorld()` and return me the results of it\n    Server--&gt;&gt;-Client: Done deal boss (sends data to the client)\n\n\n\n\n\n\nCode-wise this will look like this\n\nDSI::datashield.aggregate(\n  conns = conns,\n  expr = call(\"helloWorld()\")\n)\n\nHere in this case the function is returning something, so we can assign it myValue &lt;- DSI::datashield.aggregate(...) and use the value on the client, maybe we want to plot it or just send it to the user directly.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>1. DataSHIELD packages structure</span>"
    ]
  },
  {
    "objectID": "1-datashield-packages-structure.html#sec-ds-file",
    "href": "1-datashield-packages-structure.html#sec-ds-file",
    "title": "1. DataSHIELD packages structure",
    "section": "DATASHIELD file",
    "text": "DATASHIELD file\nexplicar que hi ha el datashiel file al paquet del servidor on especificarem quina funcio fa que, ficar alguna especie de ascii folder tree de un paquet tipic de R per explicar on va exactament\ndir que tambe es pot ficar al DESCRIPTION rollo com u fa dsOmics o dsBase.\n.\n└── dsServer/\n    ├── R/\n    │   └── ds.function.R\n    ├── inst/\n    │   └── DATASHIELD\n    ├── DESCRIPTION\n    └── NAMESPACE",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>1. DataSHIELD packages structure</span>"
    ]
  },
  {
    "objectID": "1-datashield-packages-structure.html#sec-datasources",
    "href": "1-datashield-packages-structure.html#sec-datasources",
    "title": "1. DataSHIELD packages structure",
    "section": "The datasources object",
    "text": "The datasources object\nWe have been talking about communicating between the client and the server and telling the server to run things. However, we need some object that contains the information about which server are we talking to. This oject is created by the login functions on DataSHIELD. Here a brief example\n\nbuilder &lt;- DSI::newDSLoginBuilder()\nbuilder$append(server = \"myServer\",\n               url = \"https://myDSserver.org\",\n               user = \"ds_user\", password = \"password\")\nlogindata &lt;- builder$build()\nconnections &lt;- DSI::datashield.login(logins = logindata)\n\nThis connection object is what our DSI functions will use to know to which servers to talk. For that reason, on the client functions that we write we will put an argument to pass it. Typically this argument is named datasources and defaults to NULL. It can default to NULL because DSI offers a helper function to search for this object on the client R environment and use it; nevertheless it is important that we can let the user specify which connection object they want to use, maybe someone creates two different connection on the same session and wants to use a certain one with different functions.\nHere is how a typical client function starts and how to use this helper function from DSI\n\nds.Function &lt;- function(..., datasources = NULL){\n  \n  if (is.null(datasources)) {\n    datasources &lt;- DSI::datashield.connections_find()\n  }\n\n  # Rest of the function\n\n}\n\nYou can see that the function DSI::datashield.connections_find will find the connection object on the environment and use it during the rest of the function call.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>1. DataSHIELD packages structure</span>"
    ]
  },
  {
    "objectID": "1-datashield-packages-structure.html#exercise-1",
    "href": "1-datashield-packages-structure.html#exercise-1",
    "title": "1. DataSHIELD packages structure",
    "section": "Exercise 1",
    "text": "Exercise 1\n\nCreate two R packages: dsClient and dsServer\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nMake your life easier by using usethis::create_package(\"dsClient\")\n\n\n\n\nOn the dsClient package create a function named ds.assignString that takes as input argument a string, and sends it to the assign function assignStringDS from the dsServer package.\n\n\n\n\n\n\n\nRemember\n\n\n\n\n\nAdd #' @export on top of your new R function to export it. Then, run devtools::document() so it gets added to the NAMESPACE file of your package automatically, this will allow you to library(dsClient) and be able to call ds.assignString.\n\n\n\n\nOn the dsServer package create a function named assignStringDS that takes as input argument a string, and returns that string.\nDeclare the assignStringDS as a DataSHIELD assign function.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>1. DataSHIELD packages structure</span>"
    ]
  },
  {
    "objectID": "2-dslite.html",
    "href": "2-dslite.html",
    "title": "2. DSLite: Does my package work?",
    "section": "",
    "text": "Sending data to my virtual server\nThis simple example we have just seen is pretty nice. However, one might be thinking hey typically I want my server functions to analyze tabular data, which is loaded by the user on the server session and will be used by my functions. We can also simulate this on DSLite to test our packages. Let’s see an example where we will load iris data on the virtual server.\nlibrary(dsBase)\nlibrary(dsBaseClient)\ndata(\"iris\")\nexposures &lt;- iris\nbuilder &lt;- DSI::newDSLoginBuilder()\ndslite.server &lt;- DSLite::newDSLiteServer(\n  tables=list(exposures = exposures),\n  config = DSLite::defaultDSConfiguration(\n    include=c(\"dsBase\")\n  )\n)\nbuilder$append(\n  server = \"server1\",\n  url = \"dslite.server\",\n  table = \"exposures\",\n  driver = \"DSLiteDriver\"\n)\nlogindata.dslite &lt;- builder$build()\nconns &lt;- DSI::datashield.login(\n  logins = logindata.dslite,\n  assign=T,\n  symbol = \"exposures_table\"\n)\nThis will assign the iris dataset to a variable on the server named \"exposures_table\". As before, we can check it\nDSLite::getDSLiteData(\n  conns = conns,\n  symbol = \"exposures_table\"\n)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>2. DSLite: Does my package work?</span>"
    ]
  },
  {
    "objectID": "2-dslite.html#sending-data-to-my-virtual-server",
    "href": "2-dslite.html#sending-data-to-my-virtual-server",
    "title": "2. DSLite: Does my package work?",
    "section": "",
    "text": "Pro tip\n\n\n\n\n\nWhen developing code, it is useful to be able to place debug points. This means being able to stop the execution on a certain point and look the environment, run code at that stop point etc. In R, a way of doing that is including browser() statements on the code (more on this here).\nDSLite offers us the possibility of adding them on the server functions, and when we run them the execution will be stopped so we can take debug server functions.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>2. DSLite: Does my package work?</span>"
    ]
  },
  {
    "objectID": "2-dslite.html#exercise-2",
    "href": "2-dslite.html#exercise-2",
    "title": "2. DSLite: Does my package work?",
    "section": "Exercise 2",
    "text": "Exercise 2\nAs out second exercise of the workshop, we will work on top of Exercise 1 developments.\n\nCreate a new aggregate function on the dsServer package. This function will take as input argument a data table (that will be loaded on the server). It will return to the user the number of rows of the table.\nCreate the correspondent function on dsClient that calls the server function. This function will take as input argument the name of the server table that we want to get the number of columns.\nTest the new function using DSLite.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>2. DSLite: Does my package work?</span>"
    ]
  },
  {
    "objectID": "3-datashield-filters.html",
    "href": "3-datashield-filters.html",
    "title": "3. DataSHIELD filters",
    "section": "",
    "text": "Options slot of an R package\nFilter values are only available on the server, as we do not want the analysts to be able to manipulate them, just the data owners. For that reason they are defined on the server packages. More precisely they are defined on the DESCRIPTION file of the R package. This file typically contains information about the author of the package, which dependencies it has, the licensing… more precisely these. However, this file can also contain additional metadata, this feature is what is used to declare filters with their correspondent default values on a DataSHIELD package. Take a look at the dsBase DESCRIPTION file for example.\nNow let’s continue by checking how to access those values within our package functions.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>3. DataSHIELD filters</span>"
    ]
  },
  {
    "objectID": "3-datashield-filters.html#accessing-a-filter-value",
    "href": "3-datashield-filters.html#accessing-a-filter-value",
    "title": "3. DataSHIELD filters",
    "section": "Accessing a filter value",
    "text": "Accessing a filter value\nIn order to retrieve the value of a filter on our package functions we will use the getOption function. If we want to retrieve the value of the my.new.filter filter, we will do:\n\ngetOption(\"my.new.filter\")\n\n\n\n\n\n\n\nNote\n\n\n\nIf we try to retrieve a value of an option that is not defined, it will return NULL, this can be convenient to handle exceptions.\n\n\nFollowing that we can see that if we want to use a filter from dsBase, we just have to take a look at the available ones and use them:\n\ngetOption(\"default.nfilter.glm\")\n\nAlso if we define our own filter (on our package DESCRIPTION file):\n\nOptions:\n    nice.filter=5\n\n\n\n\n\n\n\nFurther info\n\n\n\n\n\nHere we see that the filter contains a numeric variable. However they are not limited to that, they can also contain strings and other R data types.\n\nOptions:\n    even.nicer.filter=\"hello\"\n\n\n\n\nWe retrieve it by:\n\ngetOption(\"nice.filter\")",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>3. DataSHIELD filters</span>"
    ]
  },
  {
    "objectID": "3-datashield-filters.html#exercise-2",
    "href": "3-datashield-filters.html#exercise-2",
    "title": "3. DataSHIELD filters",
    "section": "Exercise 2",
    "text": "Exercise 2\nWith this new information, we should be able now to upgrade the server package we created on Exercise 1.\nfer que implementin un filter que es digui “xxxx” i que fasi algo amb lo que ia han fet al exercisi 1.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>3. DataSHIELD filters</span>"
    ]
  },
  {
    "objectID": "4-datashield-disclosure-traps.html",
    "href": "4-datashield-disclosure-traps.html",
    "title": "4. DataSHIELD disclosure traps",
    "section": "",
    "text": "We",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>4. DataSHIELD disclosure traps</span>"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>About</span>"
    ]
  }
]